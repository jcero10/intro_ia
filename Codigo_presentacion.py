# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iahplLAe-UIvdJQe72ZuwodRSyUGYHZ5

Se escribiran librerias
"""

#libreria numpy sirve para trabajar matrices y vectores
import numpy as np
import PIL.Image 
import PIL.ImageDraw


#Por defecto no viene face_recognition en google colab, por eso lo instalamos.
#!pip install face_recognition 
import face_recognition


#--------------------#

#Cargaremos la imagen en formate de matriz con la funcion load_image_file
imagen = face_recognition.load_image_file("lagartos.jpg")

#Encuentra 4 puntos de cada cara en la fotografia entregada
localizacion_caras  = face_recognition.face_locations(imagen)

#len permite saber la cantidad de elemento dentro de la variable, en este caso, la cantidad de caras que hay (por cada 4 puntos, es una cara)
numero_de_caras = len(localizacion_caras)
print("Yo encontre {} cara(s) en esta fotografia.".format(numero_de_caras))




#--------------------#


#Permite recrear la imagen desde la matriz cargada anteriormente
imagen_con_cuadros = PIL.Image.fromarray(imagen)
#Es el orden en que se entregan los puntos al encontrar una cara con face_locations
top, right, bottom, left = localizacion_caras[12]
#Entregamos la imagen que queremos editar
draw = PIL.ImageDraw.Draw(imagen_con_cuadros)
#Este es el orden para dibujar un cuadrado con draw, es diferente al orden de face_locations
draw.rectangle([left, top, right, bottom], outline = "red")


#Matplotlib nos permite dibujar y visualizar datos, imagenes, etc.
import matplotlib.pyplot as plt
plt.figure(figsize = (20,20)) #Permite agrandar la imagen al momento de visualizar.
plt.imshow(imagen_con_cuadros)
plt.show()


#--------------------#


#Encuentra  caracteristicas esenciales de la cara y las guarda en un diccionario
puntos_de_cara = face_recognition.face_landmarks(imagen)
numero_de_caras_2 = len(puntos_de_cara)
print("Yo encontre {} cara(s) en esta foto".format(numero_de_caras_2))

cara_definida = PIL.Image.fromarray(imagen)
draw = PIL.ImageDraw.Draw(cara_definida)


#Hacer un bucle sobre cada cara
for puntos in puntos_de_cara:
    #Bucle sobre cada caracteristica facial (ojos, barbilla, nariz,etc)
  for nombre, lista_de_puntos in puntos.items():
    print("El {} en esta cara tiene los siguientes puntos: {}". format(nombre, lista_de_puntos))
    draw.line(lista_de_puntos, fill = "red", width = 2)

plt.figure(figsize = (20,20))
plt.imshow(cara_definida)
plt.show()


#--------------------#

#Carga una imagen en formato array
jose = face_recognition.load_image_file("yo.jpg")
#Codifica la cara, encontrando 128 dimensiones particulares de cada una
codificar_mediciones_jose = face_recognition.face_encodings(jose)
print(codificar_mediones)


#--------------------#


#Carga la imagen con varias personas
con_amigos = face_recognition.load_image_file("lagartos.jpg")
#Encuentra las caras, el parametro "number_of_times_to_upsample" mientras mas alto el numero, permite encontrar caras más pequeñas
caras_encontradas = face_recognition.face_locations(con_amigos, number_of_times_to_upsample=2 )
codificar_con_amigos = face_recognition.face_encodings(con_amigos,known_face_locations= caras_encontradas)
codificar_con_amigos



#--------------------#

#Bucle para revisar si nos encontramos en la foto con nuestros amigos.

#Ira comparando las dimensiones de cada cara encontrada con la nuestra. Según Euclides, cuando es menor a 0.6 es por que nuestras caracteristicas son muy parecidas.
for desconocido in codificar_con_amigos:
  resultado = face_recognition.compare_faces(codificar_mediciones_jose, desconocido, tolerance = 0.6)
  nombre= "Desconocido"

  if resultado[0]:
    nombre = "Jose"
  else: 
    nombre = "No se encontro"

  print(f"Se encontro {nombre} en la foto")
  
  
  
#--------------------#
#Codificaremos la cara de chayanne, para encontrar las 128 dimensiones que lo caracterizan, luego las compararemos con las nuestras.
chayanne = face_recognition.load_image_file("chayanne.jpg")
chayanne_codificado = face_recognition.face_encodings(chayanne)

#--------------------#

#Es la formula de distancia de euclides.
np.linalg.norm(chayanne_codificado[0]- codificar_mediciones[0])


#--------------------#

#es la misma formula anterior. Distancia de Euclides.
from scipy.spatial import distance
distancia = distance.euclidean(chayanne_codificado[0] , codificar_mediciones[0])
distancia

